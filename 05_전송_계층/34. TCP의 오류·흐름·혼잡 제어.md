# TCP의 오류·흐름·혼잡 제어

TCP는 재전송을 기반으로 다양한 **오류**를 **제어**하고, **흐름 제어**를 통해 처리할 수 있을 만큼의 데이터만을 주고받으며, **혼잡 제어**를 통해 네트워크가 혼잡한 정도에 따라 전송량을 조절합니다.

---

## 오류 제어: 재전송 기법

신뢰성을 보장하기 위해서는 오류를 제어할 수 있어야 합니다. 이를 위해 TCP는 잘못된 세그먼트를 재전송하는 방법을 사용합니다. TCP의 **재전송 기반 오류 제어**가 어떻게 이루어지는지 알아봅시다.

### 오류 검출과 재전송

TCP 세그먼트에는 오류 검출을 위한 체크섬 필드가 존재하지만, 이것만으로는 신뢰성을 완전히 보장하지 못합니다. 체크섬은 세그먼트가 훼손되었는지 판단할 수 있지만, 송신 호스트는 오류 발생 여부를 알 수 없습니다.

TCP가 신뢰성을 보장하려면 다음이 필요합니다:

1. 송신 호스트가 전송한 세그먼트에 문제가 발생했음을 인지할 수 있어야 함  
2. 오류를 감지하면 해당 세그먼트를 재전송할 수 있어야 함

#### 1. 중복된 ACK 수신 시

- 수신 측에서 특정 순서 번호의 세그먼트를 받지 못했을 경우, 그 앞의 세그먼트에 대한 **중복된 ACK**를 송신합니다.
- 송신 측은 중복된 ACK를 반복해서 수신하면 오류가 발생했음을 감지하고 재전송을 수행합니다.

![중복된 ACK 이미지](https://github.com/user-attachments/assets/01827817-4212-4bb2-a891-e35df8185cb2)

#### 2. 타임아웃 발생 시

- 송신 호스트는 **재전송 타이머**를 유지합니다.
- 세그먼트를 보낼 때마다 타이머를 시작하고, 일정 시간 안에 ACK를 받지 못하면 **타임아웃**으로 간주하여 세그먼트를 재전송합니다.

![타임아웃 이미지](https://github.com/user-attachments/assets/dccd7220-82a8-4568-9dfd-d78d4397a830)

---

## ARQ (Automatic Repeat reQuest): 재전송 기법

오류를 감지한 후 신뢰성을 확보하기 위한 기법입니다. 수신자의 응답(ACK) 또는 타임아웃에 따라 손상된 세그먼트를 재전송합니다.

### Stop-and-Wait ARQ

- 송신자는 하나의 세그먼트를 전송하고, ACK를 수신한 후에 다음 세그먼트를 전송  
- 단순하지만 네트워크 활용도가 낮음

**장점:** 단순하고 구현이 쉬움  
**단점:** 대기 시간이 길어 전송 속도 저하

![Stop-and-Wait 이미지](https://github.com/user-attachments/assets/7a89770c-84f1-42c3-94dd-a498aa09f7f8)

**해결책:**  
- **파이프라이닝(pipelining)** 기법을 도입하여 ACK 없이도 여러 세그먼트를 연속적으로 전송

---

### Go-Back-N ARQ

- 파이프라이닝을 활용하여 여러 세그먼트를 전송  
- 오류가 발생한 세그먼트 이후 모든 세그먼트를 **다시 전송**

![Go-Back-N 이미지](https://github.com/user-attachments/assets/caf03319-ca06-4d9f-a2ef-181b9789555c)

**빠른 재전송 (Fast Retransmit):**  
- 동일한 ACK를 3번 수신하면 타이머 만료 전에 즉시 재전송 수행

---

### Selective Repeat ARQ

- 수신자는 오류가 난 세그먼트만 **선택적으로 재전송** 요청  
- 각 세그먼트에 대해 **개별 ACK** 전송  
- **Go-Back-N**은 누적 확인 응답, **Selective Repeat**은 개별 확인 응답

![Selective Repeat 이미지](https://github.com/user-attachments/assets/9f051ad4-5d9d-48d9-8738-01f02196bbe5)

> 오늘날 대부분의 TCP 호스트는 Selective Repeat ARQ를 지원합니다.  
> 미지원 시 Go-Back-N 방식으로 동작합니다.

---

## 흐름 제어: 슬라이딩 윈도우

TCP의 두 번째 핵심 기능인 **흐름 제어**는 송수신 호스트 간 데이터 처리 속도를 조절해 **버퍼 오버플로(buffer overflow)**를 방지합니다.

### 수신 버퍼와 버퍼 오버플로

- **수신 버퍼**: 수신 호스트가 받은 세그먼트를 임시 저장하는 공간
- 송신 측이 수신 버퍼 크기를 고려하지 않고 과도한 데이터를 보내면 **버퍼 오버플로** 발생
- **버퍼 오버플로**란: 수신 호스트가 처리할 수 있는 데이터보다 많은 양의 데이터가 도착하여 처리되지 못하는 상황

### 슬라이딩 윈도우

- **슬라이딩 윈도우**는 흐름 제어를 위한 기법
- **윈도우(Window)**: 송신 측이 한 번에 전송할 수 있는 최대 데이터 양
- 수신 측은 자신의 수신 가능 범위를 윈도우 크기로 송신 측에 전달
- 송신 측은 윈도우 크기만큼 확인 응답(ACK) 없이 세그먼트를 전송 가능
- ACK 수신에 따라 윈도우가 오른쪽으로 ‘슬라이딩’하며 다음 데이터 전송 가능

![슬라이딩 윈도우 이미지](https://github.com/user-attachments/assets/6bb27893-700d-4080-95b9-839eac68812c)

---

## 혼잡 제어

### 혼잡이란?

- 네트워크에 **과도한 트래픽**이 몰려 패킷이 지연되거나 유실되는 상황

![혼잡 상황 이미지](https://github.com/user-attachments/assets/94a350f7-bd24-47d1-9cd6-249a316b37e1)

### 혼잡 제어란?

- 송신 측이 네트워크의 혼잡 상황을 판단하여 **전송 속도를 조절**하는 기능
- 흐름 제어는 수신 측 중심, 혼잡 제어는 송신 측 중심

### 혼잡 윈도우 (Congestion Window, cwnd)

- 혼잡 없이 전송 가능한 데이터의 양을 나타냄
- 수신 윈도우와 혼잡 윈도우 중 작은 값을 기준으로 실제 전송량 결정

---

## TCP 혼잡 제어 알고리즘

### 1. AIMD (Additive Increase, Multiplicative Decrease)

- **합으로 증가** (혼잡 없음)  
  → 혼잡 윈도우를 RTT마다 1씩 선형 증가  
- **곱으로 감소** (혼잡 발생)  
  → 혼잡 윈도우를 절반으로 감소  
- 반복하며 전송 속도 조절

![AIMD 이미지](https://github.com/user-attachments/assets/62621474-8724-4a5c-abdc-b9c899f48556)

---

### 2. 느린 시작 (Slow Start)

- **혼잡 윈도우를 1부터 시작**
- ACK 하나당 혼잡 윈도우를 1씩 증가
- RTT마다 **지수적으로 증가** (2배씩 증가)

![느린 시작 이미지](https://github.com/user-attachments/assets/f4492c05-9aaf-41d7-8c14-2c6b031cbd72)

---

### 3. 혼잡 회피 (Congestion Avoidance)

- 일정 임계치 이후에는 혼잡 윈도우를 **선형 증가**
- RTT마다 혼잡 윈도우를 1 MSS씩 증가
- 혼잡 위험을 줄이기 위한 점진적 증가 전략

![혼잡 회피 이미지](https://github.com/user-attachments/assets/17d9b9af-302a-4ad8-b055-1753c9338869)

---

### 4. 빠른 회복 (Fast Recovery)

- 중복된 ACK 3번 수신 → **빠른 재전송 + 빠른 회복**
- 혼잡 윈도우를 감소시키되 **느린 시작은 건너뜀**
- 빠르게 혼잡 회피 상태로 복귀

> 단, 빠른 회복 중 타임아웃이 발생하면 다시 느린 시작으로 진입

---

## 혼잡 제어 알고리즘 종합 흐름

![혼잡 제어 종합 이미지](https://github.com/user-attachments/assets/bcbc3bec-851e-4ed7-ba4a-0dbd7616fe7b)

---

## 용어 정리

- **RTT (Round-Trip Time)**: 메시지를 전송한 후 응답이 돌아오기까지 걸리는 시간
- **MSS (Maximum Segment Size)**: 세그먼트 하나의 최대 크기

